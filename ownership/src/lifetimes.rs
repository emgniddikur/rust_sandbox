//! # Lifetimes
//!
//! ライフタイムはその参照が有効になるスコープ
//!
//! 全ての参照はライフタイムを保持する
//!
//! ダングリング参照を回避するためのもの
//!
//! 借用チェッカー⋯スコープを比較して借用が有効かをチェックする
//!
//! 変数のライフタイムより、参照のライフタイムが長く覆われていなければならない
//!
//! ライフタイム注釈はライフタイムを変えるわけではない
//!
//! ## 関数
//!
//! ライフタイム注釈は複数の参照のジェネリックなライフタイム引数が互いにどう関係するかを示すもの
//!
//! コンパイラは注釈なしでも関数内のコードを解析できるが、関数に関数外からの参照や関数外への参照がある場合は、コンパイラが引数や戻り値のライフタイムを自力で解決することがほぼできなくなる。そのライフタイムは関数を呼び出す度に異なる可能性があるため、手動でライフタイムを注釈する必要がある
//!
//! ライフタイムに代入されるスコープは最小のもの
//!
//! 何にライフタイム引数を指定する必要があるかは、関数の実装に依存する
//!
//! 関数から参照を返す場合、戻り値型のライフタイム引数は、引数のどれかに一致させる必要がある
//!
//! 究極的には関数の引数と戻り値のライフタイムを接続することに関するもの
//!
//! ## 構造体
//!
//! 構造体に参照を保持させることもできるが、ライフタイム注釈が必要
//!
//! 構造体のインスタンスはフィールドの参照よりも長生きできない
//!
//! ライフタイム省略規則
//!
//! - 参照の各引数は独自のライフタイム引数を得る
//! - 入力ライフタイム引数が1つの場合は出力ライフタイム引数と同じになる
//! - メソッドの場合で `self` がある場合は、 `self` のライフタイムが出力ライフタイム引数に代入される
//!
//! ## 静的ライフタイム
//!
//! `'static` ⋯プログラム全体の期間
//!
//! 文字列リテラルは全て `'static`

// xとyのライフタイムのうち、小さい方が'aに代入される
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// fn exec_longest() {
//     let string1 = String::from("long string is long");
//     let result;
//     {
//         let string2 = String::from("xyz");
//         result = longest(string1.as_str(), string2.as_str());
//     }
//     println!("The longest string is {}", result);
// }

fn longest2<'a>(x: &'a str, y: &str) -> &'a str {
    x
}

// 引数が1つだけの場合はライフタイム注釈は必要ない
fn func(s: &str) -> &str {
    s
}

struct S<'a> {
    s: &'a str,
}

impl<'a> S<'a> {
    // ライフタイム注釈を省略した場合、selfのライフタイムが出力ライフタイム引数に代入される
    fn method(&self, s: &str) -> &str {
        self.s
    }

    fn method2<'b>(&self, s: &'b str) -> &'b str {
        s
    }
}

pub fn main() {}
